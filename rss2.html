<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JoelYing</title>
    <link>https://joelying.github.io/</link>
    <atom:link href="/rss2.html" rel="self" type="application/rss+xml"/>
    
    <description>半个兴趣使然的程序员</description>
    <pubDate>Thu, 23 Jan 2020 10:18:10 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>本地项目提交至GitHub仓库简述</title>
      <link>https://joelying.github.io//blog/%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4%E8%87%B3GitHub%E4%BB%93%E5%BA%93%E7%AE%80%E8%BF%B0.html</link>
      <guid>https://joelying.github.io//blog/%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4%E8%87%B3GitHub%E4%BB%93%E5%BA%93%E7%AE%80%E8%BF%B0.html</guid>
      <pubDate>Thu, 23 Jan 2020 10:02:49 GMT</pubDate>
      <description>
      
        美好的东西从来不会寻求关注
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Thu Jan 23 2020 18:19:14 GMT+0800 (GMT+08:00) --><img class="joel-img" src="http://image.joelyings.com/2020-01-23_3.jpg"><a id="more"></a><p>适用情况：本地有一个项目，github上新建了一个仓库</p><p>只需要进行下面几步就能把本地项目上传到Github：</p><p>1、在本地创建一个版本库（即文件夹），通过git init把它变成Git仓库</p><p>2、把项目下的文件复制到这个文件夹里面，再通过git add .把项目添加到仓库</p><p>3、再通过git commit -m “注释内容”把项目提交到仓库</p><p>4、看C盘的用户目录下有没有.ssh目录，有的话看下里面有没有id_rsa和id_rsa.pub这两个文件，没有就通过下面命令创建</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh-keygen</span> <span class="selector-tag">-t</span> <span class="selector-tag">rsa</span> <span class="selector-tag">-C</span> "<span class="selector-tag">youremail</span>@<span class="keyword">example</span>.<span class="keyword">com</span>"</span><br></pre></td></tr></table></figure><p>然后登录Github，找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才<code>id_rsa.pub</code>里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key，这样就完成了SSH Key的加密</p><p>5、新建一个远程仓库，通过<code>git remote add origin https://github.com/xxx/xxx.git</code>将本地仓库和远程仓库进行关联</p><p>6、最后通过</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> -u <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><p>把本地仓库的项目推送到远程仓库（也就是Github）上，（若新建远程仓库的时候自动创建了README文件会报错，<code>error: failed to push some refs to &#39;https://github.com/xxx/xxx.git&#39;</code> ）</p><p>这时候可以，强制合并</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin <span class="keyword">master</span> <span class="title">--force</span></span><br></pre></td></tr></table></figure><p>以后只需要<code>git push origin master</code>即可</p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>https://joelying.github.io//blog/%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4%E8%87%B3GitHub%E4%BB%93%E5%BA%93%E7%AE%80%E8%BF%B0.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>pymysql流式游标</title>
      <link>https://joelying.github.io//blog/pymysql%E6%B5%81%E5%BC%8F%E6%B8%B8%E6%A0%87.html</link>
      <guid>https://joelying.github.io//blog/pymysql%E6%B5%81%E5%BC%8F%E6%B8%B8%E6%A0%87.html</guid>
      <pubDate>Thu, 23 Jan 2020 02:25:53 GMT</pubDate>
      <description>
      
        世间万般难事皆可在女子大腿上办妥
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Thu Jan 23 2020 18:19:14 GMT+0800 (GMT+08:00) --><img class="joel-img" src="http://image.joelyings.com/2020-01-23_1.jpg"><a id="more"></a><p>Python通过pymysql操作向mysql读取千万、百万级别的数据库时</p><p>如果用传统的<code>fetchall()</code>或<code>fetchone()</code>方法，都是先默认在内存里缓存下所有行然后再处理，大量的数据会导致内存资源消耗光，内存容易溢出</p><p>此时则建议使用<code>SSCursor</code>(流式游标)，避免客户端占用大量内存</p><p>这个 cursor 实际上没有缓存下来任何数据，它不会读取所有所有到内存中，它的做法是从储存块中读取记录，并且一条一条返回给你,使用迭代器而不用 fetchall ,即省内存又能很快拿到数据</p><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_pan_url</span><span class="params">(self)</span>:</span></span><br><span class="line">    db = pymysql.connect(host=<span class="string">'localhost'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, passwd=<span class="string">''</span>, db=<span class="string">''</span>)</span><br><span class="line">    cursor = db.cursor(cursor=pymysql.cursors.SSDictCursor)</span><br><span class="line"></span><br><span class="line">    select_sql = <span class="string">"select `name`, `detail_url`, `pan_title`, `pan_psw`, `pan_real_url` from agepan_wj"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.execute(select_sql)</span><br><span class="line">        <span class="comment"># 在处理大量数据时可以分割进行</span></span><br><span class="line">        datas = cursor.fetchall()</span><br><span class="line">        <span class="keyword">for</span> pan <span class="keyword">in</span> datas:</span><br><span class="line">            self.row_lists.append(pan)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'取数据失败'</span>, e)</span><br><span class="line">        db.rollback()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        cursor.close()</span><br><span class="line">        db.close()</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><p>因为<code>SSCursor</code>是没有缓存的游标，结果集只要没取完，这个<code>connect</code>是不能再处理别的<code>sql</code>，包括另外生成一个<code>cursor</code> 也不行的，如果需要干别的，请另外再生成一个连接对象</p><p>每次读取后处理数据要快，不能超过 60 s，否则<code>mysql</code>将会断开这次连接</p><p>也可以修改<code>SET NET_WRITE_TIMEOUT = xx</code>来增加超时间隔</p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>https://joelying.github.io//blog/pymysql%E6%B5%81%E5%BC%8F%E6%B8%B8%E6%A0%87.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Scrapy命令行动态传参给spider</title>
      <link>https://joelying.github.io//blog/Scrapy%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8A%A8%E6%80%81%E4%BC%A0%E5%8F%82%E7%BB%99spider.html</link>
      <guid>https://joelying.github.io//blog/Scrapy%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8A%A8%E6%80%81%E4%BC%A0%E5%8F%82%E7%BB%99spider.html</guid>
      <pubDate>Thu, 23 Jan 2020 02:23:33 GMT</pubDate>
      <description>
      
        世间痴情男儿，不论地位高低，大抵都是喜欢女子便是错了，而且希望能一辈子知错不改
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Thu Jan 23 2020 18:19:14 GMT+0800 (GMT+08:00) --><img class="joel-img" src="http://image.joelyings.com/2020-01-23_2.jpg"><a id="more"></a><h3 id="scrapy命令行执行传递多个参数给spider-动态传参"><a href="#scrapy命令行执行传递多个参数给spider-动态传参" class="headerlink" title="scrapy命令行执行传递多个参数给spider 动态传参"></a>scrapy命令行执行传递多个参数给spider 动态传参</h3><p>在命令行运行scrapy爬虫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl spider_name</span><br></pre></td></tr></table></figure><p>若爬虫中有参数可以控制爬取的页数，那么想要在输入命令行命令时传递页数给爬虫，就可以这样做</p><p>在spider中定义一个构造函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pages=None, *args, **kwargs)</span>:</span></span><br><span class="line">    super(LvideoSpider, self).__init__(*args, **kwargs)</span><br><span class="line">    <span class="comment"># super().__init__(**kwargs)</span></span><br><span class="line">    self.pages = pages</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    pages = re.findall(<span class="string">r'当前:1/(\d+)页'</span>, response.text, re.S)[<span class="number">0</span>]</span><br><span class="line">    link = response.meta[<span class="string">'format_page'</span>]</span><br><span class="line">    <span class="comment"># 如果self.pages存在，那么就会代替正则取到的页数</span></span><br><span class="line">    <span class="keyword">if</span> self.pages:</span><br><span class="line">        pages = self.pages</span><br><span class="line">        print(<span class="string">'共'</span> + str(pages) + <span class="string">'页'</span>)</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>, int(pages) + <span class="number">1</span>):</span><br><span class="line">        page_link = link.format(page)</span><br><span class="line">        <span class="keyword">yield</span> Request(page_link, callback=self.parse_video_link,</span><br><span class="line">                      meta=&#123;<span class="string">'soucre_name'</span>: response.meta[<span class="string">'soucre_name'</span>],</span><br><span class="line">                            <span class="string">'domin'</span>: response.meta[<span class="string">'domin'</span>],</span><br><span class="line">                            <span class="string">'page_link'</span>: page_link&#125;, dont_filter=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>然后在启动scrapy的时候就可以赋予参数的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl spider_name -a pages=<span class="number">10</span></span><br></pre></td></tr></table></figure><p>这样就控制了爬取页数为10页</p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>https://joelying.github.io//blog/Scrapy%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8A%A8%E6%80%81%E4%BC%A0%E5%8F%82%E7%BB%99spider.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>mysql保存数据时含有单引号报错方法</title>
      <link>https://joelying.github.io//blog/Python%E6%93%8D%E4%BD%9Cmysql%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E6%97%B6%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%90%AB%E6%9C%89%E5%8D%95%E5%BC%95%E5%8F%B7%E6%8A%A5%E9%94%99%E6%96%B9%E6%B3%95.html</link>
      <guid>https://joelying.github.io//blog/Python%E6%93%8D%E4%BD%9Cmysql%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E6%97%B6%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%90%AB%E6%9C%89%E5%8D%95%E5%BC%95%E5%8F%B7%E6%8A%A5%E9%94%99%E6%96%B9%E6%B3%95.html</guid>
      <pubDate>Wed, 22 Jan 2020 09:22:39 GMT</pubDate>
      <description>
      
        最苦是相思，最远是阴阳
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Thu Jan 23 2020 18:19:14 GMT+0800 (GMT+08:00) --><img class="joel-img" src="http://image.joelyings.com/2020-01-22_2.jpg"><a id="more"></a><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>mysql在保存视频名称时遇到的数据插入错误，查一下原因发现报错视频名称主要都带有<code>&#39;</code>单引号，会导致SQL语句被截断，从而产生错误</p><p>解决办法如下：</p><p>替换成两个单引号即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = str(name).replace(<span class="string">'\''</span>, <span class="string">'\'\''</span>)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>https://joelying.github.io//blog/Python%E6%93%8D%E4%BD%9Cmysql%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E6%97%B6%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%90%AB%E6%9C%89%E5%8D%95%E5%BC%95%E5%8F%B7%E6%8A%A5%E9%94%99%E6%96%B9%E6%B3%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>写作备忘</title>
      <link>https://joelying.github.io//blog/%E5%86%99%E4%BD%9C%E5%A4%87%E5%BF%98.html</link>
      <guid>https://joelying.github.io//blog/%E5%86%99%E4%BD%9C%E5%A4%87%E5%BF%98.html</guid>
      <pubDate>Wed, 22 Jan 2020 09:01:51 GMT</pubDate>
      <description>
      
        我以后想去学医，然后做一副药，药的名字叫做“相忘于江湖”，治的病叫做“不能相濡以沫”
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- build time:Thu Jan 23 2020 18:19:14 GMT+0800 (GMT+08:00) --><img class="joel-img" src="http://image.joelyings.com/2020-01-22_1.jpg"><a id="more"></a><h3 id="写作备忘"><a href="#写作备忘" class="headerlink" title="写作备忘"></a>写作备忘</h3><h4 id="新建博文"><a href="#新建博文" class="headerlink" title="新建博文"></a>新建博文</h4><p>进入<code>xxx\joelYing.github.io</code>文件夹下，右键<code>Git Bash Here</code></p><p>在打开的<code>Git Bash</code>中输入</p><p><code>hexo n &quot;标题&quot;</code></p><p>即可生成对应文章标题的<code>.md</code>文件，然后在<code>xxx\joelYing.github.io\source\_posts\xxx.md</code>下就可以写文章了</p><h4 id="保存发布"><a href="#保存发布" class="headerlink" title="保存发布"></a>保存发布</h4><p>在打开的<code>Git Bash</code>中输入</p><p><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></p><h4 id="提交GitHub分支"><a href="#提交GitHub分支" class="headerlink" title="提交GitHub分支"></a>提交GitHub分支</h4><p><code>git add .</code></p><p><code>git commit -m &quot;hexo source&quot;</code></p><p><code>git push origin source</code></p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>https://joelying.github.io//blog/%E5%86%99%E4%BD%9C%E5%A4%87%E5%BF%98.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
